# План маленькими шагами (шаги — выполняй по порядку, каждый — отдельный небольшой тикет/коммит)

Я разбил твою задачу на **много мелких, чётких и выполнимых шагов** — так будет проще идти итерациями, писать тесты и фиксировать прогресс. Для каждого шага указано что реализовать и какой артефакт получить (файл/тест/коммит). Не даю оценки времени — выполняй в своём темпе и делай коммиты по шагам.

---

## Фаза 0 — подготовка репозитория и сборки

1. Инициализировать git-репозиторий, создать README с кратким описанием проекта и списком задач.
   *Артефакт:* `README.md`, initial commit.

2. Создать структуру каталогов:

   ```
   /scanner-cli         # консольное приложение (exe)
   /scanner-lib         # DLL (shared library) с логикой сканирования
   /tests               # gtest юнит-тесты
   /third_party         # (опционально) external libs (md5 impl)
   CMakeLists.txt       # корневой
   ```

   *Артефакт:* пустые директории + CMake проект skeleton.

3. Настроить CMake для сборки трёх целей: `scanner-cli`, `scanner-lib` (shared), `scanner-tests` (gtest). Убедиться, что на Windows собирается DLL и exe.
   *Артефакт:* рабочий `CMakeLists.txt`, `cmake` сборка генерируется.

---

## Фаза 1 — базовый рекурсивный обход файлов (одно поточное)

4. Написать простую функцию рекурсивного обхода `std::filesystem` (C++17+) — собирает список файлов (абсолютные пути). Игнорировать директории типа симлинков / циклы (или обрабатывать аккуратно).
   *Вывод в консоль:* каждый путь новой строкой.
   *Артефакт:* `scanner-lib/src/traversal.cpp/.h` + тесты.

5. Добавить CLI-переменную `--path` (или позиционный аргумент) в `scanner-cli`, чтобы вызвать функцию обхода и вывести пути в консоль.
   *Артефакт:* `scanner-cli/main.cpp`.

6. Написать юнит-тесты для обхода: создать временную директорию (в тесте), создать вложенные файлы/папки и проверить, что функция вернула все пути.
   *Артефакт:* тесты `tests/traversal_test.cpp`.

---

## Фаза 2 — вычисление MD5 (потоковый, поддержка больших файлов)

7. Подключить/реализовать MD5-функцию, которая **читает файл блочно** (например, 64KB буффер) и вычисляет MD5 по стриму (не загружая весь файл в память). Можно:

   * использовать лёгкую реализацию MD5 (файлы `md5.h`/`md5.cpp`) в `third_party`, или
   * использовать OpenSSL (если готов подключать внешнюю зависимость).
     *Артефакт:* `scanner-lib/src/md5.cpp/.h`.

8. Написать простой тест для MD5: для наборов данных (пустой файл, маленький, большой — сгенерировать) проверить корректность хеша (например, сравнить с заранее известным md5sum).
   *Артефакт:* `tests/md5_test.cpp`.

9. Интегрировать MD5 в обход: для каждого файла вычислять хеш и выводить в консоль: `<path> <md5>`.
   *Артефакт:* обновлённый `scanner-cli` демонстрирующий вывод.

---

## Фаза 3 — парсер CSV базы хешей

10. Реализовать парсер CSV (разделитель `;`) который читает CSV-файл, пропускает пустые строки и строки-комментарии (по желанию), и возвращает `std::unordered_map<std::string, std::string>` где key=md5, value=verdict.
    *Артефакт:* `scanner-lib/src/hash_db.cpp/.h`.

11. Написать юнит-тесты для парсера CSV: проверить нормальные строки, ошибочные строки, дубликаты (если дубликат — последний перезаписывает?).
    *Артефакт:* `tests/csv_test.cpp`.

12. Добавить CLI-параметр `--base base.csv` и в режиме демонстрации вывести в консоль количество записей в базе и пример (первые N).
    *Артефакт:* `scanner-cli` параметризованный вывод.

---

## Фаза 4 — сравнение хешей и вердикты, логгирование

13. Добавить структуру `struct ScanRecord { std::string path; std::string md5; std::string verdict; }`.
    *Артефакт:* header в `scanner-lib/include`.

14. Реализовать логику сравнения: если md5 файла присутствует в map базы — сформировать вердикт (string), иначе `Clean` или `Unknown`.
    *Артефакт:* `scanner-lib/src/matcher.cpp`.

15. Реализовать потокобезопасный логгер, который пишет в текстовый файл (передаваемый через `--log report.log`). Формат строки, например:

    ```
    2025-09-14T12:34:56Z;<path>;<md5>;<verdict>
    ```

    Логгер должен поддерживать атомарную запись строк из разных потоков (mutex или отдельный writer thread).
    *Артефакт:* `scanner-lib/src/logger.cpp/.h`.

16. При обнаружении вредоносного файла — логгировать запись и также выводить краткий уведом в консоль.
    *Артефакт:* интеграция в `scanner-cli`.

17. Написать тест, который имитирует параллельную запись логов (много потоков) и проверяет целостность лог-файла (строки не пересекаются).
    *Артефакт:* `tests/logger_test.cpp`.

---

## Фаза 5 — сбор статистики и обработка ошибок

18. Внести счётчики: `total_files`, `malicious_count`, `error_count` (например, чтение файла не удалось). Использовать `std::atomic` для потоковой безопасности.
    *Артефакт:* `scanner-lib/include/statistics.h`.

19. Добавить возврат финального `ScanSummary { totals..., duration }` из библиотечного API. CLI должен печатать отчёт (как в ТЗ): общее число файлов, зло-файлов, ошибок, время выполнения.
    *Артефакт:* `scanner-cli` финальный отчёт.

20. Обрабатывать ошибки чтения: при неудаче чтения файла (permission denied, locked) — увеличивать `error_count` и логгировать событие (`ERROR;<path>;<what>`).
    *Артефакт:* код обработки ошибок + тесты (симулировать файл без прав).

---

## Фаза 6 — многопоточность (producer-consumer)

21. Спроектировать простую архитектуру:

    * Producer: рекурсивно обходит FS и ставит пути файлов в `concurrent queue`.
    * Pool workers: берут путь, хешируют файл, сравнивают с базой, логгируют, увеличивают счётчики.
    * Option: выделить один writer-поток для логирования (producer-consumer) или использовать mutex вокруг файла.
      *Артефакт:* `scanner-lib/src/threadpool.cpp/.h` и queue.

22. Реализовать thread-pool (фиксированное число worker-ов = hardware\_concurrency) или использовать `std::async` — но лучше свой pool.
    *Артефакт:* threadpool implementation.

23. Написать тест на корректность многопоточной работы: использовать набор файлов, запустить сканирование и проверить, что `total_files == найдено в FS` и логи корректны.
    *Артефакт:* `tests/concurrency_test.cpp`.

24. Обрабатывать отмену/отказ: корректно завершать при SIGINT (Ctrl+C) — очищать очередь и корректно закрывать лог (опционально). На Windows обработай `CTRL_C_EVENT`.
    *Артефакт:* graceful shutdown code.

---

## Фаза 7 — DLL API и интерфейс между exe и DLL

25. Спроектировать C API/extern "C" заголовок для DLL, который экспортирует минимум:

    ```cpp
    extern "C" __declspec(dllexport) bool ScanDirectory(
       const char* basePath,
       const char* csvPath,
       const char* logPath,
       ScanSummary* outSummary);
    ```

    Или класс с COM-like функциями.
    *Артефакт:* `scanner-lib/include/scanner_api.h`.

26. Реализовать экспорт функции в DLL и собрать DLL через CMake. Сделать простую загрузку в `scanner-cli` (линковка) и тест вызова.
    *Артефакт:* DLL + `scanner-cli` использует DLL.

27. Написать юнит-тесты (gtest) для DLL API (вызов функции с тестовым набором файлов и CSV).
    *Артефакт:* `tests/dll_api_test.cpp`.

---

## Фаза 8 — CLI: парсинг аргументов, валидация, пользовательский UX

28. Добавить полноценный парсер параметров (можно использовать `cxxopts` или ручной парсинг). Поддержать:

    * `--base <file>`
    * `--log <file>`
    * `--path <dir>`
    * `--threads <n>` (опционально)
    * `--help`
      *Артефакт:* `scanner-cli/main.cpp` с аргументами.

29. Валидация: проверить существование базы, права на запись в лог, существование пути. Выводить понятные ошибки.
    *Артефакт:* валидационные сообщения.

30. Добавить опцию `--dry-run` (не писать лог, только отчёт) и `--verbose` (логировать все файлы в консоль для отладки).
    *Артефакт:* опции CLI.

---

## Фаза 9 — тесты, финальные мелочи, CMake и упаковка

31. Добавить unit-тесты на все модули: traversal, md5, csv, matcher, logger, threadpool, dll\_api. Убедиться, что тесты запускаются через `ctest` / `make test`.
    *Артефакт:* `tests/*` и рабочий `ctest`.

32. Улучшить CMake: добавь targets `install` и переменную `BUILD_SHARED_LIBS` и опции для тестов. Добавь профили Debug/Release.
    *Артефакт:* улучшенный `CMakeLists.txt`.

33. Написать небольшой `CONTRIBUTING.md` и инструкцию "Как собрать на Windows" в README (команды cmake и msbuild / Visual Studio).
    *Артефакт:* docs.

34. Собрать релизный архив `ИМЯ_ФАМИЛИЯ_С++` с исходниками, бинарниками, инструкцией и тестами. Подготовить для загрузки.
    *Артефакт:* zip архив.

35. (Опционально) Сделать простой CI (GitHub Actions) для сборки и запуска тестов на пуш — если хочешь автоматизировать.
    *Артефакт:* `.github/workflows/ci.yml`.

---

## Рекомендации по работе и коммитам

* Делай **малые коммиты по каждому шагу** (каждый пункт — отдельный branch/PR или коммит).
* После каждого шага должно быть минимум один проходящий юнит-тест, если применимо.
* Для MD5 используй потоковую реализацию — это ключевая вещь для больших файлов.
* Логи делай append-only и потокобезопасно. Формат лога — простой CSV/TSV (время;путь;хеш;вердикт).
* Старайся покрывать негативные кейсы тестами: нечитаемые файлы, пустые CSV, дубли в CSV.

---

## Мини-чеклист (быстро пометить что закончено)

* [ ] Репозиторий + CMake skeleton
* [ ] Traversal (single-thread) + tests
* [ ] MD5 streaming + tests
* [ ] CSV parser + tests
* [ ] Matcher + verdicts
* [ ] Logger (thread-safe) + tests
* [ ] Counters и финальный отчёт
* [ ] Thread-pool (workers) + tests
* [ ] DLL API + tests
* [ ] CLI парсер + опции (`--path`, `--base`, `--log`, `--threads`)
* [ ] Финал: упаковка, README, zip

---

Если хочешь — могу:

* сгенерировать **шаблоны** файлов (CMakeLists, заголовки `scanner_api.h`, пример `main.cpp`) прямо сейчас;
* или написать пример **MD5 streaming** реализации на C++ и тест к ней.

Скажи, какой следующий маленький шаг хочешь получить в виде кода (например: *"сгенерируй CMake skeleton + header для DLL и пример main.cpp"*) — и я сразу создам.
